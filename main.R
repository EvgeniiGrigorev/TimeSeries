kings <- scan("http://robjhyndman.com/tsdldata/misc/kings.dat",skip=3)

# Для временных рядов по месяцам ставим frequency=12, а для данных
# по кварталам frequency=4, т.е. ts(kings, frequency=12)
kingstimeseries <- ts(kings)
kingstimeseries

# Можно установить первый год, в который собирались данные, и первый интервал в
# году с помощью параметра start функции ts(). Например, если первая точка данных
# соответствует второму кварталу 1986 года, установливаем start=c(1986,2)

births <- scan("http://robjhyndman.com/tsdldata/data/nybirths.dat")
birthstimeseries <- ts(births, frequency=12, start=c(1946,1))
birthstimeseries

souvenir <- scan("http://robjhyndman.com/tsdldata/data/fancy.dat")
souvenirtimeseries <- ts(souvenir, frequency=12, start=c(1987,1))
souvenirtimeseries

plot.ts(kingstimeseries)


# Есть сезонные колебания во временном рядо: есть пик каждое
# лето и дно каждую зиму. Временной ряд может быть описан аддитивной
# моделью, поскольку сезонные колебания примерно постоянны с течением времени и
# не зависят от уровня временного ряда, и случайные колебания также примерно постоянны по
# значению в течение долгого времени.
plot.ts(birthstimeseries)


# Аддитивная модель не подходит для описания временного ряда,
# т.к. размер сезонных колебаний и случайные флуктации возрастают с увеличением уровня
# временного ряда. Необходимо преобразовать временной ряд для того, чтобы получить 
# некоторый ряд, который можно описать с использованием аддитивной модели.
plot.ts(souvenirtimeseries)

# Лог-преобразованный временной ряд, может быть описан с использованием аддитивной модели
logsouvenirtimeseries <- log(souvenirtimeseries)
plot.ts(logsouvenirtimeseries)

# Разложение временного ряда (разделение его на составляющие компоненты), обычно это
# тренд и нерегулярная составляющая, и если это периодический ряд, сезонная компонента.

# Разложение непериодических данных
# Непериодический временной ряд состоит из составляющей тренда и нерегулярной компоненты

# Для оценки трендовой составляющей в непериодических временных рядах, которые могут
# быть описаны аддитивной моделью, используется метод сглаживания (вычислением простого скользящего среднего)

# Функция SMA() пакета «TTR» может быть использована для сглаживания временного ряда при
# помощи скользящего среднего

library(TTR)

# Функция SMA() сглаживает данные временного ряда. Необходимо указать порядок (ширину) простого
# скользящего среднего, используя параметр n.
kingstimeseriesSMA3 <- SMA(kingstimeseries,n=3)
plot.ts(kingstimeseriesSMA3)


# Множество случайных флуктаций всё ещё проявляется во временном ряде,
# сглаженном при помощи простого скользящего среднего порядка 3

kingstimeseriesSMA8 <- SMA(kingstimeseries,n=8)
plot.ts(kingstimeseriesSMA8)

# Чтобы оценить составляющую тренда и периодическую составляющую периодического
# временного ряда, который может быть описан аддитивной моделью, используется
# функция decompose(). Это функция оценивает тренд, периодическую и нерегулярную
# составляющие временного ряда, который может быть описан аддитивной моделью.

# Функиция decompose() возвращает список объектов в качестве результата, где содержатся
# оценки периодической составляющей, тренда и нерегулярной компоненты, хранящиеся в
# именованых элементах этого списка объектов, называемых «seasonal», «trend» и «random»
# соответственно.

birthstimeseriescomponents <- decompose(birthstimeseries)

# Оценки значений тренда, периодической и нерегулярной компоненты будут сохранены в
# переменных:

birthstimeseriescomponents$seasonal
birthstimeseriescomponents$trend
birthstimeseriescomponents$random

plot(birthstimeseriescomponents)

# Для исключения сезонной составляющей временного ряда количественной величины по
# месяцам, оценим сезонную составляющую, используя decompose(), и
# затем вычитаем сезонную компоненту из исходного временного ряда:
  
birthstimeseriescomponents <- decompose(birthstimeseries)
plot(birthstimeseriescomponents)
birthstimeseriesseasonallyadjusted <- birthstimeseries - birthstimeseriescomponents$seasonal

# График без сезонной составляющей
plot(birthstimeseriesseasonallyadjusted)

# Экспоненциальное сглаживание может быть использовано для краткосрочных прогнозов
# данных временного ряда.

# Простое экспоненциальное сглаживание

# Если временной ряд может быть описан аддтивной моделью с постоянным уровнем и не
# содержит сезонных колебаний, можно использовать простое экспоненциальное
# сглаживание для краткосрочного прогнозирования.

# Простое экспоненциальное сглаживание даёт возможность оценить уровень в текущей точке.
# Сглаживание определяется параметром alpha, изменяющимся в диапазоне от 0 до 1.
# Значения alpha, которые близки к 0 означают, что более старым наблюдениям в истории
# будут присвоены меньшие веса при прогнозировании будущих значений.

rain <- scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat",skip=1)
rainseries <- ts(rain,start=c(1813))
plot.ts(rainseries)

# Как видно из графика, уровень остаётся примерно постоянным (среднее значение остаётся 
# постоянным на уровне 25 дюймов). Случайные отклонения во временном ряде примерно
# постоянны по значению, следовательно, мы можем описать данные используя аддитивную
# модель. То есть, мы можем прогнозировать при помощи простого экспоненциального
# сглаживания.

# Чтобы использовать HoltWinters() для простого экспоненциального
# сглаживания, мы должны установить параметр beta=FALSE и gamma=FALSE в функции
# HoltWinters() (параметры beta и gamma используются в экспоненциальном сглаживании
# Хольта и в экспоненциальном сглаживании Хольта-Винтера).

rainseriesforecasts <- HoltWinters(rainseries, beta=FALSE, gamma=FALSE)
rainseriesforecasts

# Оценка значения параметра alpha ~= 0.024. Это очень близко к 0, 
# Значит, прогноз основан на более поздних значениях и в меньшей степени на ранних значениях.

# По умолчанию, HoltWinters() делает прогноз только для того же периода времени, что и в
# исходном временном ряду. В это случае, исходный временной ряд включает данные за 1813-1912,
# так что прогноз тоже для периода 1813-1912.

plot(rainseriesforecasts)
plot(fitted(rainseriesforecasts))

predict.rainseriesforecasts <- predict(rainseriesforecasts, n.ahead = 10, prediction.interval = TRUE, level = 0.95)
plot(rainseriesforecasts, predict.rainseriesforecasts)